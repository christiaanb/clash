--
-- Simple module providing some types used by Translator. These are in a
-- separate module to prevent circular dependencies in Pretty for example.
--
module TranslatorTypes where

import qualified Control.Monad.State as State
import qualified Data.Map as Map

import qualified HscTypes

import qualified ForSyDe.Backend.VHDL.AST as AST

import FlattenTypes
import VHDLTypes
import HsValueMap


-- | A map from a HsFunction identifier to various stuff we collect about a
--   function along the way.
type FuncMap  = Map.Map HsFunction FuncData

-- | Some stuff we collect about a function along the way.
data FuncData = FuncData {
  flatFunc     :: Maybe FlatFunction,
  funcEntity   :: Maybe Entity,
  funcArch     :: Maybe AST.ArchBody
}

data VHDLSession = VHDLSession {
  coreMod   :: HscTypes.CoreModule, -- The current module
  nameCount :: Int,             -- A counter that can be used to generate unique names
  funcs     :: FuncMap          -- A map from HsFunction to FlatFunction, HWFunction, VHDL Entity and Architecture
}

-- | Add the function to the session
addFunc :: HsFunction -> VHDLState ()
addFunc hsfunc =
  modFuncMap (Map.insert hsfunc (FuncData Nothing Nothing Nothing))

-- | Find the given function in the current session
getFunc :: HsFunction -> VHDLState (Maybe FuncData)
getFunc hsfunc = do
  fs <- State.gets funcs -- Get the funcs element from the session
  return $ Map.lookup hsfunc fs

-- | Gets all functions from the current session
getFuncs :: VHDLState [(HsFunction, FuncData)]
getFuncs = do
  fs <- State.gets funcs -- Get the funcs element from the session
  return $ Map.toList fs

-- | Gets all the functions from the current session
getHsFuncs :: VHDLState [HsFunction]
getHsFuncs = do
  fs <- State.gets funcs -- Get the funcs element from the session
  return $ Map.keys fs
  
-- | Sets the FlatFunction for the given HsFunction in the current session.
setFlatFunc :: HsFunction -> FlatFunction -> VHDLState ()
setFlatFunc hsfunc flatfunc =
  modFunc (\d -> d { flatFunc = Just flatfunc }) hsfunc

-- | Sets the Entity for the given HsFunction in the current session.
setEntity :: HsFunction -> Entity -> VHDLState ()
setEntity hsfunc entity =
  modFunc (\d -> d { funcEntity = Just entity }) hsfunc

-- | Sets the Entity for the given HsFunction in the current session.
setArchitecture :: HsFunction -> AST.ArchBody -> VHDLState ()
setArchitecture hsfunc arch =
  modFunc (\d -> d { funcArch = Just arch }) hsfunc

-- | Modify a function in the map using the given function
modFunc :: (FuncData -> FuncData) -> HsFunction -> VHDLState ()
modFunc f hsfunc =
  modFuncMap (Map.adjust f hsfunc)

-- | Modify the function map in the session using the given function
modFuncMap :: (FuncMap -> FuncMap) -> VHDLState ()
modFuncMap f = do
  fs <- State.gets funcs -- Get the funcs element from the session
  let fs' = f fs
  State.modify (\x -> x {funcs = fs' })

-- | Apply the given function to all functions in the map, and collect the
--   results. The function is allowed to change the function map in the
--   session, but any new functions added will not be mapped.
modFuncs :: (HsFunction -> FuncData -> VHDLState ()) -> VHDLState ()
modFuncs f = do
  hsfuncs <- getHsFuncs
  mapM doFunc hsfuncs
  return ()
  where
    doFunc hsfunc = do
      fdata_maybe <- getFunc hsfunc
      case fdata_maybe of
        Nothing -> do return ()
        Just fdata -> f hsfunc fdata

getModule :: VHDLState HscTypes.CoreModule
getModule = State.gets coreMod -- Get the coreMod element from the session

type VHDLState = State.State VHDLSession

-- Makes the given name unique by appending a unique number.
-- This does not do any checking against existing names, so it only guarantees
-- uniqueness with other names generated by uniqueName.
uniqueName :: String -> VHDLState String
uniqueName name = do
  count <- State.gets nameCount -- Get the funcs element from the session
  State.modify (\s -> s {nameCount = count + 1})
  return $ name ++ "_" ++ (show count)

-- vim: set ts=8 sw=2 sts=2 expandtab:
