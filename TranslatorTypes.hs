--
-- Simple module providing some types used by Translator. These are in a
-- separate module to prevent circular dependencies in Pretty for example.
--
module TranslatorTypes where

import qualified Control.Monad.State as State
import Flatten

type FuncMap = [(HsFunction, 
    (FlatFunction))]

data VHDLSession = VHDLSession {
  nameCount :: Int,             -- A counter that can be used to generate unique names
  funcs     :: FuncMap          -- A map from HsFunction to FlatFunction, HWFunction, VHDL Entity and Architecture
} deriving (Show)

-- Add the function to the session
addFunc :: HsFunction -> FlatFunction -> VHDLState ()
addFunc hsfunc flatfunc = do
  fs <- State.gets funcs -- Get the funcs element from the session
  State.modify (\x -> x {funcs = (hsfunc, flatfunc) : fs }) -- Prepend name and f

type VHDLState = State.State VHDLSession

-- Makes the given name unique by appending a unique number.
-- This does not do any checking against existing names, so it only guarantees
-- uniqueness with other names generated by uniqueName.
uniqueName :: String -> VHDLState String
uniqueName name = do
  count <- State.gets nameCount -- Get the funcs element from the session
  State.modify (\s -> s {nameCount = count + 1})
  return $ name ++ "_" ++ (show count)

